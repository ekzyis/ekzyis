<code>
<strong>
<pre class="text-center">
 _     _             
| |__ | | ___   __ _ 
| '_ \| |/ _ \ / _` |
| |_) | | (_) | (_| |
|_.__/|_|\___/ \__, |
               |___/ </pre>
</strong>
</code>
<div>
  <div class="font-mono mb-1 text-center">
    2023-08-09<br />
    <strong>Demystifying WireGuard and iptables</strong><br />
    <small>15 minutes</small>
  </div>
  <hr />
  <div class="text-left mb-1">
    <h1>introduction</h1>
    <p>
      In this blog post, I will show you how to setup
      <a target="_blank" href="https://wireguard.com">WireGuard</a>
      and configure your Linux firewall with
      <a target="_blank" href="https://wiki.archlinux.org/title/iptables"><code class="code">iptables</code></a>.
    </p>
    <P>
      We will establish a point-to-point connection between two machines across the internet.<br />
      One machine ("the local machine") sits behind a
      <a target="_blank" href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a> router
      and therefore is not reachable from the public internet.
      The other machine ("the remote machine") has a static public IPv4 address and sits in a data center (for example,
      if you rent a server from cloud providers).
      This is the simplest network topology and therefore useful to get the basics down first.
    </p>
    <p>
      In following blog articles, I will show you how to create more advanced network topologies which include VPN
      gateways and port forwarding <a href="#ft-0">[0]</a>.
      VPN gateways connect multiple devices together and port forwarding is usually used to expose internal services to
      the internet.
    </p>
    <p>
      It is important to me that you get a good understanding of <code class="code">iptables</code> and how to use it
      from this post since I think there is a lack of good guides about it.
      I believe it is way more helpful to explain fundamentals well
      compared to just handing out instructions to follow. With a good understanding, you will be able to help yourself
      a lot better in case you run into problems.
    </p>
  </div>
  <hr />
  <div class="text-left">
    <h1>iptables primer</h1>
    <p>
      <code class="code">iptables</code> is a command line utility for configuring Linux kernel firewalls.
    </p>
    <p>
      It acts upon <i>tables</i> which consist of <i>chains</i> which in turn consist of <i>rules</i> and
      a <i>policy</i>. The rules have criteria for packets and <i>targets</i> like <i>ACCEPT</i> or <i>DROP</i>.
      These targets are basically actions which are executed if a packet matches.
      For example, a rule could check if a packet comes from a specific IP address range and use the ACCEPT
      target to accept it and let it pass through the firewall. Chain policies are used as fallback targets in case no
      rule matches.
    </p>
    <p>
      Each table has a specific purpose.
      For example, the default table (which is used if you don't specify a table in a command) is the <i>filter</i>
      table which contains an <i>INPUT</i>, <i>FORWARD</i> and <i>OUTPUT</i> chain and is used to accept or drop IP
      packets.
      This is the only table we will need in this post. There is also the <i>nat</i>
      table (which we will use for port forwarding in a future blog post) and
      <a target="_blank" href="https://wiki.archlinux.org/title/iptables#Tables">three others</a>,
      but they are very specialized and thus not needed in the vast majority of use cases.
    </p>
    <p>During the lifetime of a packet inside the Linux firewall,
      the chains of tables are consulted to decide the fate of a packet.
      The chains traverse through their rules in order until they find a matching rule whose target terminates the chain
      <a href="#ft-1">[1]</a>. If no matching rule was found, then the chain's policy target is used.
    </p>
    <p>The order of the chains is defined in this (simplified) flow chart <a href="#ft-2">[2]</a>:</p>
    <img class="flex m-auto" src="/blog/img/iptables_flowchart.png" />
    <p>
      Packets that come in on any network interface enter this flow chart at the top and thus go first through the
      PREROUTING chain of the nat table.
      However, not all packets originate from outside a network interface or reach the bottom of this flow chart.
      Packets for local processes stop at <code>[local process]</code> and packets which are generated by local
      processes enter this flow chart at <code>[local process]</code>.
    </p>
    <p>
      The routing decision after the PREROUTING chain involves deciding if the final destination of the packet is the
      local machine (in which case the packet traverses to the INPUT chain at the left)
      or another machine in case we act as a router (in which case the packet traverses to the FORWARD
      chain at the right).<br />
      The routing decision after <code>[local process]</code> involves assigning a source address, which outgoing
      interface to use and other necessary information. Since the packet may have changed inside the nat table which
      could affect routing, there is a final routing decision just before the POSTROUTING chain to consider these
      changes.
    </p>
    <p>
      With <code class="code">iptables -S</code> (short for <code class="code">iptables --list-rules</code>),
      we can lookup the current firewall configuration for a table.
      You can specify a table like this: <code class="code">iptables -t nat -S</code>.
      For example, the filter table of a host inside a home network could look like this
      <i>(as mentioned, if you don't specify a table, the filter table is used)</i>:
    </p>
    <pre class="code"><code>$ iptables -S
-P INPUT DROP
-P FORWARD DROP
-P OUTPUT DROP
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -j LOG --log-prefix "[INPUT:DROP] " --log-level 6
-A OUTPUT -p udp -m udp --sport 67:68 --dport 67:68 -m comment --comment DHCP -j ACCEPT
-A OUTPUT -p udp -m udp --dport 53 -m comment --comment DNS -j ACCEPT
-A OUTPUT -p udp -m udp --sport 123 --dport 123 -m comment --comment NTP -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 80 -m comment --comment HTTP -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 443 -m comment --comment HTTPS -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 22 -m comment --comment SSH -j ACCEPT
-A OUTPUT -j LOG --log-prefix "[OUTPUT:DROP] " --log-level 6</code></pre>
    <p>
      The first three statements show that the chain policy for the INPUT, FORWARD and OUTPUT chains is to drop packets.
      This means that any packet not matched by any (terminating) rule will be dropped.
    </p>
    <p>
      The OUTPUT chain contains rules to allow outgoing packets for various common application layer protocols like
      DHCP, DNS, NTP, HTTP, HTTPS and SSH.
      The INPUT chain contains a rule which only allows packets for <i>related</i> or <i>established</i> connections.
      This makes the firewall <i>stateful</i>.
    </p>
    <p>
      Additionally, packets are logged before they are dropped by the chain policies. This uses the <i>LOG</i> target
      which is
      a non-terminating target. Logging packets is very useful for debugging or can be used before applying new
      firewall rules to make sure you don't lock yourself out accidentally.
    </p>
    <p>
      A packet is considered to be part of an established connection if it is part of a response to outgoing or incoming
      packets. For example, if you're browsing a website, the incoming packets carrying the requested web page
      content would be considered as part of an established connection. This makes the firewall stateful since it needs
      to keep an internal state of outgoing and incoming packets.
    </p>
    <p>
      A connection is considered related when it is related to another established connection.
      A good example of related connections are data connections in FTP since FTP creates new connections for data
      transfers instead of reusing the current established connection to the server. Kernel modules like
      <a target="_blank" href="https://github.com/torvalds/linux/blob/master/net/netfilter/nf_conntrack_ftp.c">this</a>
      implement connection tracking for individual protocols such that related connections can be found by the
      firewall.
    </p>
    <p>
      The syntax in the output of <code class="code">iptables -S</code> is the same syntax you would use to configure
      the firewall.<br />
      This means that we can set the INPUT chain policy to ACCEPT with
    </p>
    <pre class="code"><code>$ iptables -P INPUT ACCEPT</code></pre>
    <p>whereas with</p>
    <pre class="code"><code>$ iptables -A INPUT -p tcp --dport 3000 -j ACCEPT</code></pre>
    <p>we could append a rule to the INPUT chain to open port 3000 for TCP packets.</p>
    <p>
      Other useful commands are
    </p>
    <pre class="code"><code>$ iptables -D &ltchain&gt &ltrulenum&gt</code></pre>
    <p>to delete rules or</p>
    <pre class="code"><code>$ iptables -R &ltchain&gt &ltrulenum&gt &ltrule-specification&gt</code></pre>
    <p>to replace rules with a rule number and a rule specification like</p>
    <code class="code">-p &ltproto&gt --dport &ltdestination port&gt -j &lttarget&gt</code>.<br />
    <p>You can look up rule numbers with <code class="code">--line-numbers</code>:</p>
    <pre class="code"><code>$ iptables -S --line-numbers</code></pre>
    <p>These were all commands we will use in this blog post.</p>
    <p>
      If anything is still unclear, don't hesitate to refer to the
      <a target="_blank" href="https://man.archlinux.org/man/iptables.8.en">manual</a>
      or ask a question in the <a target="_blank" href="https://stacker.news/items/221471">comments</a>.
    </p>
  </div>
  <hr />
  <div class="text-left">
    <h1>wireguard</h1>
    <h2>installation</h2>
    <p>
      Follow the instructions <a target="_blank" href="https://www.wireguard.com/install/">here</a> to install WireGuard
      on your local and remote machine.<br />
      When you're done, you should be able to run the following command:
    </p>
    <pre class="code"><code>$ wg --version
wireguard-tools v1.0.20210914 - https://git.zx2c4.com/wireguard-tools/</code></pre>
    <h2>configuration</h2>
    <p>
      WireGuard is a peer-to-peer (P2P) protocol like Bitcoin. This means that by default, the protocol does not
      distinguish between servers and clients.
      To create VPN gateways or any other network topology, you will have to configure your peers accordingly.
      In this blog post, we will only connect two peers together so we can keep the configuration simple.<br />
    </p>
    <h3>key generation</h3>
    <p>
      WireGuard uses asymmetric cryptography for its encryption.
      Therefore, you need to generate a key pair using the commands
      <code class="code">genkey</code> and <code class="code">pubkey</code> on your local
      and remote machine. As mentioned in
      <a target="_blank" href="https://man.archlinux.org/man/wg.8#pubkey"><code class="code">man wg</code></a>, you can
      generate a key pair with secure file
      permissions
      (handled by <a target="_blank" href="https://wiki.archlinux.org/title/umask"><code class="code">umask</code></a>)
      like this:
    </p>
    <pre class="code"><code>$ umask 077
$ wg genkey | tee /etc/wireguard/wg_private.key | wg pubkey > /etc/wireguard/wg_public.key</code></pre>
    <p>
      This will generate a private key at <i>/etc/wireguard/wg_private.key</i> and a public key at
      <i>/etc/wireguard/wg_public.key</i> which are only readable and writeable by the current user
      <a href="#ft-3">[3]</a>.
    </p>
    <p><i>local machine keys:</i></p>
    <pre class="code"><code>$ cat /etc/wireguard/wg_private.key
l0c4l+s3cR37+RDr+dJdgX/ACeRQLANiduQRJK9O23A=
$ cat /etc/wireguard/wg_public.key
/wH4OzafBUJVvRGzK8itUweV/GpwoUzn7OS99lr7gHI=</code></pre>
    <p><i>remote machine keys:</i></p>
    <pre class="code"><code>$ cat /etc/wireguard/wg_private.key
r3M073+s3cR37+fouaQZbP5QqfgwypHjKGBNmztxNEc=
$ cat /etc/wireguard/wg_public.key
GL33DRrI8/2yAT6+r5mTtBLd7CoErAAsio3yNqQ3K1M=</code></pre>
    </p>
    <h3>ip range selection</h3>
    <p>
      You need to decide which IP range you want to use for your virtual private network (VPN). This will be the IP
      range from which you will assign IP addresses to hosts inside the VPN.
      <strong>The important part is to not pick an IP range which is already in use.</strong>
      Fortunately, the IPv4 specification reserved following IP ranges for use in private networks
      <a href="#ft-4">[4]</a>:
    <ul>
      <li>10.0.0.0/8</li>
      <li>172.16.0.0/12</li>
      <li>192.168.0.0/16</li>
    </ul>
    IP addresses in these ranges are not routable in the public internet since they are ignored by all public routers.
    For example, my local area network (LAN) uses 192.168.178.0/24 <a href="#ft-5">[5]</a>:
    <pre class="code"><code>$ ip address
  ... other output ...
  2: enp3s0: &ltBROADCAST,MULTICAST,UP,LOWER_UP&gt mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 9c:6b:00:06:a7:54 brd ff:ff:ff:ff:ff:ff
    inet <strong>192.168.178.146/24</strong> brd 192.168.178.255 scope global dynamic noprefixroute enp3s0
    valid_lft 804365sec preferred_lft 804365sec
    inet6 fe80::6de5:ba8f:c52b:52bd/64 scope link noprefixroute
    valid_lft forever preferred_lft forever</code></pre>
    If you are already part of other private networks (company or university VPN for example), you can check the
    IP ranges they use by connecting and running <code class="code">ip address</code> afterwards as above.<br />
    In this blog post, we will assume that <strong>10.172.16.0/24</strong> is still free to use and thus can be selected
    for our VPN.
    </p>
    <h3>peer configuration</h3>
    <p>
      We can configure our peers via the file <i>/etc/wireguard/wg0.conf</i> <a href="#ft-6">[6]</a>.
      As with the keys, it makes sense to run <code class="code">umask 077</code> before creating the files.
      The files will then be created with read and write access only given to the current user.
    </p>
    <p>
      For every peer, we need to define the interface by specifying the private key and IP address.
      For the remote machine, we also need to set <code>ListenPort</code> to specify on which port the machine should
      listen for incoming WireGuard UDP packets.
      We don't set it for the local machine since we don't need a fixed port. We only need a fixed port
      if peers need to know the port in advance to initiate connections.
      However, the local machine is not reachable from the
      internet so it is not possible to initiate connections to it.
      Therefore, we rely on the local machine initiating connections.
      WireGuard will pick a random free port when the interface is brought up.
    </p>
    <p>
      We also need to define the peers of every peer in the configuration.
      This is done by adding a peer section which starts with <code>[Peer]</code> per peer.
      Since we only have one peer per peer, there will only be a single <code>[Peer]</code> section per
      configuration.<br />
      We need to set the public key of every peer such that WireGuard can use this public key to encrypt the packets.
      The peers can then decrypt the packets using their private key. We also need to set which IP addresses we want to
      route to each peer via <code>AllowedIPs</code>. In our case here, this will just be the IP address of each peer.
      When we setup a VPN gateway, this will be more interesting since there, we will route packets through multiple
      peers.
    </p>
    <p>
      For the local machine, we will also set <code>Endpoint</code> to the <strong>public</strong>
      IP address of the remote machine
      and port as used in <code>ListenPort</code>.
      This lets WireGuard know how to reach the peer to establish a VPN connection.
    </p>
    <p>
      To keep the connection alive, we will also use
      <code>PersistentKeepalive</code> in the local machine configuration.
      This specifies the interval in seconds in which keep-alive packets are sent. Without this, stateful
      firewalls may kill the VPN connection after some time since WireGuard is not a chatty protocol by itself.
      Additionally, our local machine is behind NAT which is another reason to use <code>PersistentKeepalive</code> to
      keep NAT mappings valid.
    </p>
    <p><i>local machine configuration:</i></p>
    <pre class="code"><code>[Interface]
Address = 10.172.16.2/32
PrivateKey = l0c4l+s3cR37+RDr+dJdgX/ACeRQLANiduQRJK9O23A=

[Peer]
AllowedIPs = 10.172.16.1/32
PublicKey = GL33DRrI8/2yAT6+r5mTtBLd7CoErAAsio3yNqQ3K1M=
Endpoint = 139.162.153.133:51913
PersistentKeepalive = 25</code></pre>
    <p><i>remote machine configuration:</i></p>
    <pre class="code"><code>[Interface]
Address = 10.172.16.1/32
PrivateKey = r3M073+s3cR37+fouaQZbP5QqfgwypHjKGBNmztxNEc=
ListenPort = 51913

[Peer]
AllowedIPs = 10.172.16.2/32
PublicKey = /wH4OzafBUJVvRGzK8itUweV/GpwoUzn7OS99lr7gHI=</code></pre>
    <p>
      As a last step, make sure that the file permissions are correctly set and the owner of all created files is root:
    </p>
    <pre class="code"><code>$ ls -l /etc/wireguard
-rw------- 1 root root 1155 Aug 03 15:38 wg0.conf
-rw------- 1 root root 45   Aug 03 15:31 wg_private.key
-rw-r--r-- 1 root root 45   Aug 03 15:31 wg_public.key</code></pre>
    <p>
      If the public key is readable by other users, that's fine.
      If there is something wrong with your file permissions, run these commands:
    </p>
    <pre class="code"><code>$ chown root:root -R /etc/wireguard
$ chmod 600 -R /etc/wireguard</code></pre>
    <h2>interface control</h2>
    <p>
      We are now done with all WireGuard configuration.
      Run this on the local and remote machine to bring the interfaces up:
    </p>
    <pre class="code"><code>$ wg-quick up wg0</code></pre>
    <p>If you use <code class="code">systemd</code>, you can run
      <code class="code">wg-quick up wg0</code> on boot using a systemd service:
    </p>
    <pre class="code"><code>$ systemctl enable wg-quick@wg0</code></pre>
    <p>To bring the interface down, run this:</p>
    <pre class="code"><code>$ wg-quick down wg0</code></pre>
    <p>To see configuration and peer information of interfaces, run <code class="code">wg</code>:</p>
    <pre class="code"><code>$ wg
interface: wg0
public key: /wH4OzafBUJVvRGzK8itUweV/GpwoUzn7OS99lr7gHI=
private key: (hidden)
listening port: 60646

peer: GL33DRrI8/2yAT6+r5mTtBLd7CoErAAsio3yNqQ3K1M=
endpoint: 139.162.153.133:51913
allowed ips: 10.172.16.1/32
transfer: 0 B received, 444 B sent
persistent keepalive: every 25 seconds</code></pre>
    <p>
      As you can see in the line beginning with <code>transfer</code>, we did not receive any packets yet.
      This is because we did not properly configure our firewalls yet.
    </p>
  </div>
  <hr />
  <div class="text-left">
    <h1>firewall configuration with iptables</h1>
    <h2>initial configuration</h2>
    <p>
      We are starting with the following minimal set of firewall rules for the local machine:
    </p>
    <pre class="code"><code>(local) $ iptables -S
-P INPUT DROP
-P FORWARD DROP
-P OUTPUT DROP
-A INPUT -m state --state ESTABLISHED -j ACCEPT
-A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT</code></pre>
    <p>and remote machine:</p>
    <pre class="code"><code>(remote) $ iptables -S
-P INPUT DROP
-P FORWARD DROP
-P OUTPUT DROP
-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
-A OUTPUT -m state --state ESTABLISHED -j ACCEPT</code></pre>
    <p>
      You should be able to see that these firewall rules only allow SSH access from
      the local machine to the remote machine with IP address 139.162.153.133.
      Since WireGuard uses UDP, it therefore makes sense that we currently don't have a VPN
      connection. We can check if we have a VPN connection with <code class="code">wg</code>
      (check for latest handshake or received bytes)
      or by trying to ping one machine from the other. Therefore, we run
    </p>
    <pre class="code"><code>(local) $ ping 10.172.16.1</code></pre>
    <p>at the local machine and</p>
    <pre class="code"><code>(remote) $ ping 10.172.16.2</code></pre>
    <p>at the remote machine.</p>
    <p>
      We need to run both commands since it is not guaranteed that the other direction also works if one machine can
      reach the other as you will later see. We will also keep these commands running until the end so we can
      immediately see if a VPN connection is up or was lost.
    </p>
    <p>
      To fully understand which rules are required and why, we will configure the firewall in four steps:
    </p>
    <ol>
      <li>Configure local OUTPUT chain with remote INPUT chain policy set to ACCEPT</li>
      <li>Keep VPN connection up with remote INPUT chain policy switched back to DROP</li>
      <li>Configure remote OUTPUT chain with local INPUT chain policy set to ACCEPT</li>
      <li>Keep VPN connection up with local INPUT chain policy switched back to DROP</li>
    </ol>
    <p>
      By first setting the INPUT chain policy to ACCEPT in the receiving machine,
      we can focus on a single machine at every step since we know
      that only the OUTPUT rules can currently be responsible for any connection failure.
    </p>
    <h2>local OUTPUT chain configuration</h2>
    <p>
      As mentioned, we will set the INPUT chain policy of the remote filter table to ACCEPT first:
    </p>
    <pre class="code"><code>(remote) $ iptables -P INPUT ACCEPT</code></pre>
    <pre class="code"><code><span class="diff-remove">- -P INPUT DROP</span>
<span class="diff-add">+ -P INPUT ACCEPT</span>
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</code></pre>
    <p>
      We know that <code class="code">ping</code> uses ICMP packets so we need to allow ICMP in our local firewall:
    </p>
    <pre class="code"><code>(local) $ iptables -A OUTPUT -p icmp -j ACCEPT</code></pre>
    <p>We also know that WireGuard uses UDP. This mean we need to also allow outgoing UDP packets:</p>
    <pre class="code"><code>(local) $ iptables -A OUTPUT -p udp -j ACCEPT</code></pre>
    <p>
      We have made these changes locally now:
    </p>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
<span class="diff-add">+ -A OUTPUT -p icmp -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -p udp -j ACCEPT</span></code></pre>
    <p>
      This is sufficient for a ping from the local to the remote machine:
    </p>
    <pre class="code"><code>(local) $ ping 10.172.16.1
PING 10.172.16.1 (10.172.16.1) 56(84) bytes of data.
64 bytes from 10.172.16.1: icmp_seq=18 ttl=64 time=9.28 ms
64 bytes from 10.172.16.1: icmp_seq=19 ttl=64 time=8.88 ms
64 bytes from 10.172.16.1: icmp_seq=20 ttl=64 time=9.25 ms</code></pre>
    <p>The current rules are very broad however. This is bad for security. We will fix this now.</p>
    <p>However, if we limit UDP packets to only the <code>wg0</code> interface, the ping stops working:</p>
    <pre class="code"><code>(local) $ iptables -R OUTPUT 3 -o wg0 -p udp -j ACCEPT</code></pre>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -p icmp -j ACCEPT
<span class="diff-remove">- -A OUTPUT -p udp -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -o wg0 -p udp -j ACCEPT</span></code></pre>
    <p>
      This is because <code>wg0</code> is the <i>virtual network interface</i>, not the actual physical network
      interface that sends the UDP packets. WireGuard works by wrapping all packets (like ICMP here) in UDP packets
      before sending them out "over the wire". The following chart should make more clear what this means:
    </p>
    <img class="flex m-auto" src="/blog/img/wireguard_layering.png" />
    <p>
      If we use the physical network interface
      (which is <code>enp3s0</code> for the local machine as can be seen in <code class="code">ip address</code>),
      the ping works again:
    </p>
    <pre class="code"><code>(local) $ iptables -R OUTPUT 3 -o enp3s0 -p udp -j ACCEPT</code></pre>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -p icmp -j ACCEPT
<span class="diff-remove">- -A OUTPUT -o wg0 -p udp -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -o enp3s0 -p udp -j ACCEPT</span></code></pre>
    <p>
      We can also limit the UDP packets to port 51913 of our remote machine:
    </p>
    <pre class="code">
<code>(local) $ iptables -R OUTPUT 3 -o enp3s0 -p udp -d 139.162.153.133 --dport 51913 -j ACCEPT</code></pre>
    <pre
      class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -p icmp -j ACCEPT
<span class="diff-remove">- -A OUTPUT -o enp3s0 -p udp -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</span></code></pre>
    <p>
      What would not work is to limit the UDP packets using internal IPs since the physical network interface is unaware
      of our VPN:
    </p>
    <pre class="code"><code>(local) $ iptables -R OUTPUT 3 -o enp3s0 -p udp -d 10.172.16.1 -j ACCEPT</code></pre>
    <pre class="code">
<code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -p icmp -j ACCEPT
<span class="diff-remove">- -A OUTPUT -o enp3s0 -p udp -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -d 10.172.16.1/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</span></code></pre>
    <p>
      To confirm our understanding, we can limit the ICMP packets to only the <code>wg0</code> interface. The ping
      should continue to work:
    </p>
    <pre class="code">
<code>(local) $ iptables -R OUTPUT 2 -o wg0 -p icmp -j ACCEPT</code></pre>
    <pre class="code">
<code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
<span class="diff-remove">- -A OUTPUT -p icmp -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -o wg0 -p icmp -j ACCEPT</span>
  -A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</code></pre>
    </p>
    <p>
      And it indeed does:
    </p>
    <pre class="code"><code>64 bytes from 10.172.16.1: icmp_seq=50 ttl=64 time=9.05 ms
64 bytes from 10.172.16.1: icmp_seq=51 ttl=64 time=8.78 ms
64 bytes from 10.172.16.1: icmp_seq=52 ttl=64 time=9.12 ms</code></pre>
    <p>
      Usually, all traffic is allowed inside a VPN. Therefore, this rule is commonly used:
    </p>
    <pre class="code">
<code>(local) $ iptables -R OUTPUT 2 -o wg0 -j ACCEPT</code></pre>
    <p>
      Done. The changes we applied to the local firewall configuration are:
    </p>
    <pre class="code">
<code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
<span class="diff-add">+ -A OUTPUT -o wg0 -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</span></code></pre>
    <h2>switch remote INPUT chain policy back to DROP</h2>
    <p>We will set the remote INPUT chain policy back to DROP now.</p>
    <pre class="code"><code><span class="diff-remove">- -P INPUT ACCEPT</span>
<span class="diff-add">+ -P INPUT DROP</span>
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</code></pre>
    <p>
      The ping stopped working but we know that the
      local OUTPUT chain is properly configured.
    <p>
      After allowing inbound ICMP <i>and</i> UDP packets, the ping from the local machine to the remote machine works
      again:
    </p>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
<span class="diff-add">+ -A INPUT -p icmp -j ACCEPT</span>
<span class="diff-add">+ -A INPUT -p udp -j ACCEPT</span>
  -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
</code></pre>
    <p>
      We will limit the UDP packets to only port 51913 and the physical network interface.
      The physical network interface of the remote machine is <code>eth0</code>:
    </p>
    <pre class="code"><code>(remote) $ iptables -R INPUT 3 -i eth0 -p udp --dport 51913 -j ACCEPT</code></pre>
    <p>
      To actually enable all VPN traffic from the local to the remote machine, we also need to allow it on the remote
      machine:
    </p>
    <pre class="code"><code>(remote) $ iptables -R INPUT 2 -i wg0 -j ACCEPT</code></pre>
    <p>
      Done. We applied following changes to the remote firewall:
    </p>
    <pre class="code"><code><span class="diff-remove">- -P INPUT ACCEPT</span>
<span class="diff-add">+ -P INPUT DROP</span>
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
<span class="diff-add">+ -A INPUT -i wg0 -j ACCEPT</span>
<span class="diff-add">+ -A INPUT -i eth0 -p udp -m udp --dport 51913 -j ACCEPT</span>
  -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</code></pre>
    <h2>remote OUTPUT chain configuration</h2>
    <p>
      We will take care of pinging the local machine from the remote machine now. As you can see, having a connection
      from
      one direction does not mean that the other direction works, too (even though response packets arrive).</p>
    <p>
      To focus on the OUTPUT chain configuration, we will set the local INPUT chain policy to ACCEPT:
    </p>
    <pre class="code"><code><span class="diff-remove">- -P INPUT DROP</span>
<span class="diff-add">+ -P INPUT ACCEPT</span>
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -o wg0 -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</code></pre>
    <p>
      And start with allowing outgoing ICMP packets:
    </p>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
  -A INPUT -i wg0 -j ACCEPT
  -A INPUT -i eth0 -p udp -m udp --dport 51913 -j ACCEPT
  -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
<span class="diff-add">+ -A OUTPUT -p icmp -j ACCEPT</span></code></pre>
    <p>
      However, this time, we notice that the ping already works even without allowing UDP packets:
    </p>
    <pre class="code"><code>(remote) $ ping 10.172.16.2
PING 10.172.16.2 (10.172.16.2) 56(84) bytes of data.
64 bytes from 10.172.16.2: icmp_seq=8 ttl=64 time=9.16 ms
64 bytes from 10.172.16.2: icmp_seq=9 ttl=64 time=8.74 ms
64 bytes from 10.172.16.2: icmp_seq=10 ttl=64 time=8.95 ms</code></pre>
    <p>
      The explanation is that the UDP packets are able to use an established connection.
      Only allowing TCP packets kills the connection <a href="#ft-7">[7]</a>:
    </p>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
  -A INPUT -i wg0 -j ACCEPT
  -A INPUT -i eth0 -p udp -m udp --dport 51913 -j ACCEPT
<span class="diff-remove">- -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -p tcp -m state --state ESTABLISHED -j ACCEPT</span>
  -A OUTPUT -p icmp -j ACCEPT</code></pre>
    <p>
      We could allow UDP packets through a separate rule ... :
    </p>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
  -A INPUT -i wg0 -j ACCEPT
  -A INPUT -i eth0 -p udp -m udp --dport 51913 -j ACCEPT
  -A OUTPUT -p tcp -m state --state ESTABLISHED -j ACCEPT</span>
  -A OUTPUT -p icmp -j ACCEPT
<span class="diff-add">+ -A OUTPUT -p udp -j ACCEPT</span></code></pre>
    <p>
      ... but since we don't have a specific IP address for limiting the traffic,
      we will revert back to the previous stateful rule and also allow any traffic from the virtual network interface:
    </p>
    <pre class="code"><code>(remote) $ iptables -R OUTPUT 1 -m state --state ESTABLISHED -j ACCEPT
(remote) $ iptables -D OUTPUT 3
(remote) $ iptables -R OUTPUT 2 -o wg0 -j ACCEPT</code></pre>
    <p>
      Done. We effectively only added a single rule to the remote firewall:
    </p>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
  -A INPUT -i wg0 -j ACCEPT
  -A INPUT -i eth0 -p udp -m udp --dport 51913 -j ACCEPT
  -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
<span class="diff-add">+ -A OUTPUT -o wg0 -j ACCEPT</span></code></pre>
    <h2>switch local INPUT policy back to DROP</h2>
    <p>
      We have a bidirectional connection now. The only thing left to do is to revert back to
      a local INPUT chain policy of DROP and keep the connection up.
    </p>
    <p>When going back to DROP as the INPUT chain policy ... :</p>
    <pre class="code"><code><span class="diff-remove">- -P INPUT ACCEPT</span>
<span class="diff-add">+ -P INPUT DROP</span>
-P FORWARD DROP
-P OUTPUT DROP
-A INPUT -m state --state ESTABLISHED -j ACCEPT
-A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
-A OUTPUT -o wg0 -j ACCEPT
-A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</code></pre>
    <p>... we notice that the ping continues to work. This is because of the first INPUT rule:</p>
    <pre class="code"><code>-A INPUT -m state --state ESTABLISHED -j ACCEPT</code></pre>
    <p>
      If we kill the connection and then run <code class="code">ping</code> again, it no longer works:
    <pre class="code"><code>64 bytes from 10.172.16.2: icmp_seq=93 ttl=64 time=9.16 ms
64 bytes from 10.172.16.2: icmp_seq=94 ttl=64 time=9.06 ms
64 bytes from 10.172.16.2: icmp_seq=95 ttl=64 time=8.83 ms
64 bytes from 10.172.16.2: icmp_seq=96 ttl=64 time=9.15 ms
^C
--- 10.172.16.2 ping statistics ---
96 packets transmitted, 96 received, 0% packet loss, time 95139ms
rtt min/avg/max/mdev = 8.602/9.114/9.606/0.209 ms
(remote) $ ping 10.172.16.2
PING 10.172.16.2 (10.172.16.2) 56(84) bytes of data.


</code></pre>
    <p>This is expected since it only worked because of an established connection.</p>
    <p>After allowing ICMP traffic, the ping also works immediately again:</p>
    <pre class="code"><code>  -P INPUT DROP</span>
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
<span class="diff-add">+ -A INPUT -p icmp -j ACCEPT</span>
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -o wg0 -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</code></pre>
    <p>
      This is again because the UDP packets can still use the established VPN connection.
      This is similar to what happened while configuring the remote OUTPUT chain.</p>
    <p>
      But again, the proper configuration would be to allow all traffic into the <code>wg0</code> interface but limit
      incoming UDP packets
      with a source IP address and port filter:
    </p>
    <pre class="code"><code>  -P INPUT DROP</span>
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
  -A INPUT -p icmp -j ACCEPT
<span class="diff-remove">- -A INPUT -p icmp -j ACCEPT</span>
<span class="diff-add">+ -A INPUT -i wg0 -j ACCEPT</span>
<span class="diff-add">+ -A INPUT -s 139.162.153.133/32 -i enp3s0 -p udp -m udp --sport 51913 -j ACCEPT</span>
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
  -A OUTPUT -o wg0 -j ACCEPT
  -A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</code></pre>
    <h2>final configuration</h2>
    <p><i>local firewall configuration:</i></p>
    <pre
      class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -m state --state ESTABLISHED -j ACCEPT
<span class="diff-add">+ -A INPUT -i wg0 -j ACCEPT</span>
<span class="diff-add">+ -A INPUT -s 139.162.153.133 -i enp3s0 -p udp -m udp --sport 51913 -j ACCEPT</span>
  -A OUTPUT -d 139.162.153.133/32 -p tcp -m tcp --dport 22 -j ACCEPT
<span class="diff-add">+ -A OUTPUT -o wg0 -j ACCEPT</span>
<span class="diff-add">+ -A OUTPUT -d 139.162.153.133/32 -o enp3s0 -p udp -m udp --dport 51913 -j ACCEPT</span></code></pre>
    <p><i>remote firewall configuration:</i></p>
    <pre class="code"><code>  -P INPUT DROP
  -P FORWARD DROP
  -P OUTPUT DROP
  -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
<span class="diff-add">+ -A INPUT -i wg0 -j ACCEPT</span>
<span class="diff-add">+ -A INPUT -i eth0 -p udp -m udp --dport 51913 -j ACCEPT</span>
  -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
<span class="diff-add">+ -A OUTPUT -o wg0 -j ACCEPT</span></code></pre>
  </div>
  <hr />
  <div>
    <p>
      Thanks for reading my first blog post!
      If you want to read more content like this, please consider subscribing via
      <a href="/blog/rss.xml">RSS</a>.
    </p>
    <p>
      Also, I would highly appreciate any feedback in the
      <a target="_blank" href="https://stacker.news/items/221471">comments</a>.
      You can tell me if it was too long, too boring, too complicated or anything else, that's no problem!
      I am very new to this whole blogging thing and thus could really <i>really</i>
      need <strong>any</strong> kind of feedback.
      I'll even pay you 100 sats!
    </p>
  </div>
  <hr />
  <div class="text-left">
    <small>
      <span id="ft-0">[0]
        Originally, I wanted to make a blog post how to use WireGuard and port forwarding to expose your bitcoin
        node at home to the internet with a static public IPv4 address. This avoids that inbound connections drop when
        your ISP changes your public IPv4 address. However, I realized that I want to be thorough with explaining the
        basics first and not skip anything just to get to the port forwarding part faster.
      </span><br />
      <span id="ft-1">[1]
        Some targets don't terminate the chain. For example, targets can redirect to another user-defined chain and
        then
        return or just log a packet.
      </span><br />
      <span id="ft-2">[2]
        This chart only contains the filter and nat table and was taken from <a target="_blank"
          href="https://wiki.archlinux.org/title/iptables#Basic_concepts">here</a>.
      </span><br />
      <span id="ft-3">[3]
        If you are confused by the mask 077 like me since it looks like it gives everyone full access except to
        yourself:
        as mentioned <a target="_blank" href="https://wiki.archlinux.org/title/umask">here</a>,
        <code class="code">umask</code> uses
        the logical complement of the permission bits. This means that any bit set via umask will
        <strong>not</strong>
        be set in the file permissions.
      </span><br />
      <span id="ft-4">[4] See the
        <a target="_blank" href="https://en.wikipedia.org/wiki/Private_network#Private_IPv4_addresses">wikipedia
          article</a>
        about private networks
      </span><br />
      <span id="ft-5">[5]
        If you are confused by the /24 notation, you can read about CIDR
        <a target="_blank" href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">here</a>.
      </span><br />
      <span id="ft-6">[6] You could use any other path, but <i>/etc/wireguard/</i> is searched automatically by
        <code class="code">wg-quick</code> so our commands can be kept short.
      </span><br />
      <span id="ft-7">[7]
        I am not entirely sure which established connection the UDP packets use but I think it's the VPN connection
        since it always uses the same network sockets as far as I know. If you know more about this, please let me
        know!
      </span><br />
    </small>
  </div>
</div>